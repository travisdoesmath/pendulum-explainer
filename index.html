<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaotic Pendulums</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/default.min.css">
    <link rel="stylesheet" href="style.css">
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.3.2/math.min.js"></script>
    <script src="https://d3js.org/d3.v6.min.js"></script>
</head>
<body>
    <div class="column">
        <h1>Building an n-tuple pendulum simulator from scratch</h1>
        <section id="caveat">
            <p>
                caveat: I am not a physicist, computer scientist, software engineer, or web developer. Once upon a time I knew some math, but now
                I am mostly just an intensely curious person. I've learned enough to make this work, and now I'd like to share it with you.
            </p>
        </section>
        <section id="overview-english">
            <h2>Overview (in plain English)</h2>
            <p>We will be building a simulator that runs on a webpage and animates the movement of an n-tuple pendulum.</p>
            <ul>
                <li>First, we will define the physical system that describes the motion of an n-tuple pendulum.</li>
                <li>Second, we will create a JavaScript program that solves the equations of motion and animates a given n-tuple pendulum.</li>
            </ul>
            <figure>
                <canvas id="canvas" width="400", height="400"></canvas>
                <figcaption>A real-time simulation of a quintuple pendulum</figcaption>
            </figure>
        </section>
        <section id="overview-technobabble">
            <h2>Overview (in techno-babble)</h2>
            <p>We will be building a simulator that runs on a webpage and animates the movement of an n-tuple pendulum.</p>
            <ul>
                <li>First, we will use a Lagrangian formulation to describe the equations of motion for an n-tuple pendulum. For ease of coding and solving, the equations of motion will be defined in a matrix equation \(Ax = b\).</li>
                <li>Second, we will create a JavaScript program that uses a Runge-Kutta method (RK4) to numerically solve the system of differential equations obtained in step 1 and 
                    animate the simulation using the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas">canvas element</a></li>
            </ul>
        </section>
        <section id="but-why">
            <h2>But, why?</h2>
            <p>Great question! Regular, single pendulums are a simple physical system that can be solved analytically (I think). Probably very good for learning
                the basics of physical modeling and simulation, but pretty boring.
            </p>    
            <p>Double pendulums are also a reasonably simple physical system to describe, but they are an example of a <a href="https://en.wikipedia.org/wiki/Chaos_theory">chaotic system</a>. 
                Mathematically, this means that they show <a href="https://en.wikipedia.org/wiki/Butterfly_effect">sensitive dependence to initial conditions.</a>. Visually, this means they look hypnotically awesome.
                However, there are thousands of double pendulum simulators out there. 
            </p>
            <p>Triple pendulums have pretty gnarly equations of motion when you solve for them directly, and it's not <em>that</em> much more work to just solve for the general case and set
                \(n = 3\), so we might as well just do the little bit of extra work and figure out the general case.
            </p>
        </section>
        <section id="lets-go" class="green aside">
            <h2>Let's go!</h2>
        </section>
        <section id="equations-of-motion">
            <h2>Step 1: Equations of motion</h2>
            <p>
                To simulate the movement of some physical system, we want to be able to take any snapshot of time and predict where it will move next (and how fast). 
                For example, if we toss a ball into the air, after it leaves our hand, at any given snapshot of time, the ball has some position (where it is), velocity 
                (how fast it's going), and acceleration (how the velocity is changing). With that information, we can predict where the ball will be a short time after. 
                If the ball is 2 meters (6.56 feet) in the air and moving straight up at 1 meters per second (6.71 mph), then one tenth of a second later, it will be 
                approximately 2.1 meters (6.89 feet) in the air. We can get an even better approximation if we include the acceleration, but more on that later.
            </p>
            <p>
                For a given physical system, if we had a function that took in any given time value and spit out the positions of elements in the physical system, we'd be done!
                All we'd have to do then is draw the points of the physical system at their starting point, increase the time value a little bit, and then redraw the points of the 
                physical system at their new locations, and do that <a href="https://en.wikipedia.org/wiki/Persistence_of_vision">fast enough to make it look like it's moving</a>.           
            </p>
            <p>
                Unfortunately, we rarely have a function that just tells us the position at a given time. Instead, what we can do is figure out rules to describe what is happening for
                every possible snapshot of the physical system (that is, the position of all the points in the system, their velocity, and their acceleration), and use that to determine
                the next snapshot. One way of defining those rules is called <em><a href="https://en.wikipedia.org/wiki/Lagrangian_mechanics">Lagrangian mechanics</a></em>.
            </p>
            <h3>A little bit of math notation</h3>
            <p>
                It's about to get heavy with math formulas pretty soon, so before we jump into Lagrangian mechanics, so let's be clear about the notation we're using before moving 
                on. Also, we're going to be relying on quite a bit of calculus, so if you aren't familiar with calculus, the math section is going to make a lot of logical jumps that 
                probably won't make sense to you. If you want to go research calculus on your own, the topics we'll be using are the sum rule, the power rule, the product rule, the 
                chain rule, derivatives of sine and cosine, and partial derivatives. At the end, we will also be referring to a little bit of linear algebra to describe our equations
                of motion as a matrix equation \(A \boldsymbol{x} = \boldsymbol{b}\).
            </p>
            <p>
                <ul>
                    <li>
                        \(\sum_{i=1}^{n}[\ldots]\) is <a href="https://en.wikipedia.org/wiki/Summation#Capital-sigma_notation">capital-sigma notation</a> for summation. This says
                        to sum up whatever is in \([\ldots]\) where \(i\) counts up from \(1\) to \(n\). \(i\) is the <em>index</em> that we use to keep track of each object.
                    </li>
                    <li>
                        \(f(t)\) is a function that takes \(t\) as an input, and outputs some transformed value. We just use \(f(t)\) to refer to the output. Functions can be 
                        written with any name for their input variable (often \(x\)), but in this context, \(t\) almost always means time.
                    </li>
                    <li>
                        \(\frac{d}{dt}f(t)\) is the derivative of \(f(t)\) with respect to \(t\). Here, \(t\) means time.
                    </li>
                    <li>
                        \(\dot{f}\) (notice the little dot!) is another way of writing the derivative of \(f\) with respect to time. We often use this when talking about values that 
                        are dependent on time, but where writing them as functions would be cumbersome. 
                    </li>
                    <li>
                        \(\ddot{f}\) (notice the two little dots!) is the second derivative of \(f\) with respect to time.
                    </li>
                    <li>
                        \(\frac{\partial A}{\partial x}\) is the partial derivative of a multivariate function or expression \(A\) with respect to the variable \(x\)
                    </li>
                </ul>
            </p>
            <h3>Lagrangian mechanics</h3>
            <p>
                In Lagrangian mechanics, we start with the difference of the kinetic energy (\(T\)) and the potential energy (\(V)\) of the physical system. This difference is called the
                <em>Lagrangian</em> (\(L = T - V\)). The kinetic energy of a system is defined as \(\frac{1}{2}\sum_{i=1}^{n}m_iv_i^2\) where \(m_i\) is the mass of each object (the \(i\) 
                is an index to keep track of each obect) and \(v_i^2\) is the squared magnitude of the velocity of each object. For pendulum systems, we're only going to worry
                about the gravitational potential energy. If two objects have the same mass, but one is higher up than the other, then the object that is higher up has more gravitational 
                potential energy. If two objects are at the same height, but one is more massive than the other, then the more massive object has more gravitational potential energy.
                We will represent this with the definition \(V = \sum_{i=1}^{n} gm_iy_i\) where \(g\) is the acceleration factor due to gravity, \(m_i\) is still the mass of each object, 
                and \(y_i\) is the y&#8209;position, or height, of each object.
            </p>
            <p>
                With the Lagrangian \(L\) defined, we use the following Euler-Lagrange equations to give us the equations of motion of the system:
                $$ \frac{d}{dt}\left(\frac{\partial L}{\partial \dot{q}_i}\right) = \frac{\partial L}{\partial q_i} $$
                where \(q_i\) represents some point in the system. Note: the Lagrangian may be defined in terms of abstract quantities in a 
                <a href="https://en.wikipedia.org/wiki/Phase_space">phase space</a> describing the system. For example, we will be using the phase space of angles and angular velocities
                in our formulation for the n-tuple pendulum.
            </p>
            <p>
                Now we are ready to describe the equations of motion for the n-tuple pendulum.
            </p>
            <h3>Lagrangian formulation of the n-tuple pendulum<sup><a href="#footnote-1" id="footnote-1-referrer">[1]</a></sup></h3>
            <p>
                For this simulation, we are describing a frictionless physical system of rods with zero mass and \(n\) bobs of equal mass. This means that the \(n\) bobs are the only 
                point masses of the system. For ease of calculation, the length of each rod and the mass of each bob are defined as \(1\) appropriate arbitrary unit. The gravitational 
                constant \(g\) is defined as \(-9.8\) meters per second per second.      
            </p>
            <p>
                <a href="#figure-1">Figure 1</a> shows how we will define the coordinates of each bob based on the angles of each rod.
            </p>
            <figure id="figure-1">
                <svg width="475" height="425" alt='Diagram of n-tuple pendulum' id="diagram">
                    <line x1="50" y1="0" x2="50", y2="425" stroke="#888" stroke-width="3"></line>
                    <line x1="0" y1="50" x2="475", y2="50" stroke="#888" stroke-width="3"></line>
                    <circle cx="50" cy="50" r="4" fill="#888"></circle>
                </svg>
                <figcaption>Figure 1: Diagram of coordinates of an n-tuple pendulum</figcaption>
            </figure>
            <p>
                The \(x\) and \(y\) coordinates of each bob are defined as follows:
                $$x_i = \sum_{j=1}^i\sin\theta_j, \quad y_i = -\sum_{j=1}^i\cos\theta_j$$
                $$\dot{x}_i = \sum_{j=1}^i\dot{\theta}_j\cos\theta_j, \quad \dot{y}_i = \sum_{j=1}^i\dot{\theta}_j\sin\theta_j$$    
            </p>
            <p>
                The kinetic energy of the system is defined as follows:
                $$\begin{eqnarray}
                T &=& \frac{1}{2}\sum_{i=1}^n m_i v_i^2 \\
                &=& \frac{1}{2}\sum_{i=1}^n(\dot{x}_i^2 + \dot{y}_i^2) \\
                &=& \frac{1}{2}\sum_{i=1}^n \left( \left[\sum_{j=1}^i\dot{\theta}_j\cos\theta_j\right]^2 + \left[ \sum_{j=1}^i\dot{\theta}_j\sin\theta_j \right]^2 \right) \\
                &=& \frac{1}{2}\sum_{i=1}^n \left(\sum_{j=1}^n\dot{\theta}_j^2 
                    + \sum_{j \neq k}2\dot{\theta}_j\dot{\theta}_k\cos\theta_j\cos\theta_k 
                    + \sum_{j \neq k}2\dot{\theta}_j\dot{\theta}_k\sin\theta_j\sin\theta_k\right) \\
                &=& \frac{1}{2}\sum_{i=1}^n \left(\sum_{j=1}^n\dot{\theta}_j^2 + \sum_{j \neq k}2\dot{\theta}_j\dot{\theta}_k\cos(\theta_j - \theta_k) \right) \\
                &=& \sum_{i=1}^n \left(\sum_{j=1}^n\frac{1}{2}\dot{\theta}_j^2 + \sum_{j \neq k}\dot{\theta}_j\dot{\theta}_k\cos(\theta_j - \theta_k) \right)
                \end{eqnarray}$$    
            </p>
            <p>
                The potential energy of the system is defined as follows:
                $$\begin{eqnarray}
                V &=& \sum_{i=1}^nm_igy_i \\
                &=& -g\sum_{i=1}^n\sum_{j=1}^i\cos\theta_j \\
                &=& -g\sum_{i=1}^n(n-i+1)\cos\theta_i \\
                \end{eqnarray}$$
            </p>
            <p>
                Thus the Lagrangian of the n-tuple pendulum is
                $$\begin{eqnarray}
                L &=& T - V = \sum_{i=1}^n \left(\sum_{j=1}^n\frac{1}{2}\dot{\theta}_j^2 + \sum_{j \neq k}\dot{\theta}_j\dot{\theta}_k\cos(\theta_j - \theta_k) \right) + g\sum_{i=1}^n(n-i+1)\cos\theta_i \\
                \end{eqnarray}$$    
            </p>
            <p>
                Now we use the Euler-Lagrange equations:
                $$\frac{d}{dt}\left(\frac{\partial L}{\partial \dot{\theta}_i}\right) - \frac{\partial L}{\partial \theta_i} = 0$$
            </p>
            <p>
                For the first term, we start by taking the partial derivative of the Lagrangian with respect to the angular velocities:
                $$\frac{\partial L}{\partial \dot{\theta}_i} = \sum_{j=1}^{n}c(i,j)\dot{\theta}_j\cos(\theta_i - \theta_j), \quad c(i, j) = n - \max(i, j) + 1$$
                Then we take the derivative of that result with respect to time:
                $$\frac{d}{dt}\left(\frac{\partial L}{\partial \dot{\theta}_i}\right) = 
                \sum_{j=1}^{n}c(i,j)\left[\ddot{\theta}_j\cos(\theta_i - \theta_j) - \dot{\theta}_i\dot{\theta}_j\sin(\theta_i - \theta_j) + \dot{\theta}_j^2\sin(\theta_i - \theta_j) \right]$$
            </p>
            <p>
                Now, we will derive the second term of the Euler-Lagrange equation, taking the partial derivative of the Lagrangian with respect to the angles of the rods.
                $$\frac{\partial L}{\partial \theta_i} = -g(n - i + 1)\sin\theta_i - \sum_{j=1}^nc(i,j)\dot{\theta}_i\dot{\theta}_j\sin(\theta_i - \theta_j)$$
            </p>
            <p>
                Finally, we can fill in both terms of the Euler-Lagrange equations.
                $$\begin{eqnarray}
                && \frac{d}{dt}\left(\frac{\partial L}{\partial \dot{\theta}_i}\right) - \frac{\partial L}{\partial \theta_i} = 0 \\
                    &\implies& \sum_{j=1}^{n}c(i,j)\left[\ddot{\theta}_j\cos(\theta_i - \theta_j) - \dot{\theta}_i\dot{\theta}_j\sin(\theta_i - \theta_j) + \dot{\theta}_j^2\sin(\theta_i - \theta_j) \right]
                    + g(n - i + 1)\sin\theta_i + \sum_{j=1}^nc(i,j)\dot{\theta}_i\dot{\theta}_j\sin(\theta_i - \theta_j) = 0 \\
                \end{eqnarray}$$                
                After doing some careful algebra on the terms, moving any term with a second derivative of the angles to the left-hand side, and any term without to the 
                right-hand side, we get:
                $$\begin{eqnarray}
                    && \sum_{j=1}^{n}c(i,j)\left[\ddot{\theta}_j\cos(\theta_i - \theta_j) + \dot{\theta}_j^2\sin(\theta_i - \theta_j) \right] + g(n - i + 1)\sin\theta_i = 0 \\
                    &=& \sum_{j=1}^{n}c(i,j)\ddot{\theta}_j\cos(\theta_i - \theta_j) = -\sum_{j=1}^{n}\left[c(i,j)\dot{\theta}_j^2\sin(\theta_i - \theta_j)\right] - g(n - i + 1)\sin\theta_i
                \end{eqnarray}$$   
            </p>
            <p>
                The equations of motion can be written as a matrix equation \(A \boldsymbol{x} = \boldsymbol{b}\) where 
                <ul>
                    <li>\(A\) is an \(n \times n\) matrix where the \(i,j\) entry is \(c(i,j)\cos(\theta_i - \theta_j)\),</li>
                    <li>\(\boldsymbol{x}\) is the vector of \(\ddot{\theta}_i\)'s,</li>
                    <li>and \(\boldsymbol{b}\) is the vector of values \(-\sum_{j=1}^{n}\left[c(i,j)\dot{\theta}_j^2\sin(\theta_i - \theta_j)\right] - g(n - i + 1)\sin\theta_i\) </li>
                </ul> 
            </p>
            <p>
                Remember, we are using the phase space of angles (\(\theta_i\)) and angle velocities (\(\dot{\theta}_i\)) to represent the possible states of the n-tuple pendulum
                system. To approximate the next state, we'll need the derivatives: \(\dot{\theta}_i\) and \(\ddot{\theta}_i\). Luckily, if we know the current state, we know the 
                \(\dot{\theta}_i\), and we can solve the matrix equation we just defined to get the \(\ddot{\theta}_i\).
            </p>
            <p>
                For the next bit, we'll need a function \(f\) that takes in the current state of the n-tuple pendulum and returns the derivates, that is
                $$ f \left( \begin{matrix}\theta_1 \\ \vdots \\ \theta_n \\ \dot{\theta}_1 \\ \vdots \\ \dot{\theta}_n \end{matrix} \right) = 
                     \left( \begin{matrix}\dot{\theta}_1 \\ \vdots \\ \dot{\theta}_n \\ \ddot{\theta}_1 \\ \vdots \\ \ddot{\theta}_n \end{matrix} \right) $$
            </p>
            <p>
                You might be thinking that we can find the next state of the pendulum system by taking a small change in time (\(\Delta t\)), multiplying the derivatives of the 
                state values by \(\Delta t\), and adding the resulting changes to the current state values. In other words (or at least a lot of notation),

                $$
                    \left( \begin{matrix}\theta_1 \\ \vdots \\ \theta_n \\ \dot{\theta}_1 \\ \vdots \\ \dot{\theta}_n \end{matrix} \right) \rightarrow 
                    \left( \begin{matrix}\theta_1 \\ \vdots \\ \theta_n \\ \dot{\theta}_1 \\ \vdots \\ \dot{\theta}_n \end{matrix} \right) + \Delta t 
                    \left( \begin{matrix}\dot{\theta}_1 \\ \vdots \\ \dot{\theta}_n \\ \ddot{\theta}_1 \\ \vdots \\ \ddot{\theta}_n \end{matrix} \right)
                $$

                
                If so, you're thinking along the same lines as 
                <a href="https://en.wikipedia.org/wiki/Euler_method">one of the greatest mathematicians ever</a>, but unfortunately, because the n-tuple pendulums are chaotic 
                systems, we will need a more sophisticated method. We will be using the 
                <a href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods#The_Runge%E2%80%93Kutta_method">4th order Runge-Kutta (RK4) method</a>. 

                To keep notation compact, lets define \(s_t\) to be the state at time \(t\). We can then rewrite the previous expression as

                $$ s_{t + \Delta t} = s_{t} + \Delta tf(s_t) $$
            </p>
            <p>
                We won't go into the details of RK4 or exactly how it works (the rough idea is that it takes weighted averages of slopes across the \(\Delta t\) interval), but the 
                process is as follows:

                $$
                    \begin{eqnarray} 
                    k_1 &=& f(s_t) \\
                    k_2 &=& f(s_t + \frac{\Delta t}{2} k_1 ) \\
                    k_3 &=& f(s_t + \frac{\Delta t}{2} k_2 ) \\
                    k_4 &=& f(s_t + \Delta tk_3 )
                    \end{eqnarray}
                $$

                $$ s_{t + \Delta t} \approx \frac{\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k4) $$

            </p>
            <p>
                With that, we have everything we need to start coding the n-tuple pendulum simulation in JavaScript. Whew!
            </p>
        </section>
        <section id="lets-code" class="green aside">
            <h2>Let's code!</h2>
        </section>
        <section id="javascript">
            <h2>Step 2: Coding it up in JavaScript</h2>
            <p><em>Note, if you want to jump ahead and see how this is coded, the pendulum at the top of the page is using the <a href="example">example code</a>!</em></p>
            <p>
                For this section, we're going to write all of our code for the browser, which means all you need is a text editor (I recommend 
                <a href="https://code.visualstudio.com/">Visual Studio Code</a>, which is free and works well on Mac and Windows), and a browser, which you're probably using to 
                view this page (if you're on a phone or tablet, I suggest you go to a computer. If you know how to code on a mobile device, you probably don't need my help at 
                this point.)
            </p>
            <p>
                I'm assuming you've done some coding before, so if you haven't, you might want to search for a "Hello World" tutorial in JavaScript to get started. I highly
                recommend the <a href="https://developer.mozilla.org/en-US/">Mozilla Developer Network (MDN) Web Docs</a> as a reference for all things HTML, CSS, and JavaScript.
            </p>
            <p>
                I recommend creating a coding projects folder that you can get to easily, preferably in your home/user directory. In that folder, create a new folder called 
                <code>pendulum</code>, and create a new file inside of it named <code>index.html</code>. Open <code>index.html</code> inside your text editor, and paste the
                following HTML code, and save.
            </p>
                
            <pre>
<code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.3.2/math.min.js"&gt;&lt;/script&gt;
    &lt;title>Pendulum Simulator&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;canvas id="canvas" width="500" height="500"&gt;&lt;/canvas&gt;
    &lt;script src="pendulum.js"&gt;&lt;/script&gt;
    &lt;script src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code>
            </pre>
            <p>
                Note that in VS Code, most of this code is boilerplate code that can be created with the <a href="https://code.visualstudio.com/docs/editor/emmet">Emmet 
                abbreviation</a> <code class="inline-code">!</code>.
                <img src="emmet-html.gif">
            </p>
            <p>
                This HTML code does the following:
                <ul>
                    <li>Creates the webpage with the standard elements (i.e. the <code>head</code>, <code>body</code>, <code>title</code>, etc.),</li>
                    <li>loads the <a href="https://mathjs.org/">math.js</a> library we'll be using to do some of the math for us,</li>
                    <li>and calls two JavaScript files: <code>pendulum.js</code> and <code>index.js</code></li>.
                </ul>
                The <code>pendulum.js</code> file will contain all the code that handles the pendulum simulation math, and <code>index.js</code> will contain all the code 
                responsible for displaying and animating the simulation in our browser. We will create those files now, starting with <code>pendulum.js</code>.
            </p>
            <h2><code>pendulum.js</code></h2>
            <p>
                We'll be using JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">classes</a> to define, in code, what it means to be
                an n-tuple pendulum. We'll be using the class to store properties that the system needs, like the number of bobs \(n\), the current state of the pendulum, and
                even the gravitation constant. We'll also define functions, or methods, like creating the \(A\) matrix for each state, and the coordinates of the bobs. Let's start
                with a skeleton of everything that we'll need, and fill in the details one-by-one.
            </p>
            <pre>
<code class="language-javascript">class Pendulum {
    constructor() {
    }

    A() {
    }
    
    b() {
    }
    
    f() {
    }
    
    RK4() {
    }    

    tick() {
    }

    get coordinates() {
    }

}
</code>
            </pre>
        <p>
            We'll be using this class to create an <em>instance</em> of a pendulum. The <code>constructor()</code> method will define how the instance is constructed and store the 
            starting state of the system. The other methods perform the following tasks:
            <ul>
                <li>the <code>A()</code> method will create the matrix \(A\) from our equations of motion,</li>
                <li>the <code>b()</code> method creates the vector \(b\) from our equations of motion,</li>
                <li>the <code>f()</code> method calculates the derivative of the current state values,</li>
                <li>the <code>RK4()</code> method performs the Runge-Kutta algorithm,</li>
                <li>the <code>tick()</code> method updates the state of the system,</li>
                <li>and the <code>coordinates()</code> method returns the coordinates of the bobs.</li>
            </ul>
        </p>
        <h3>The <code>constructor()</code> method</h3>
        <p>
            To create a new n-tuple pendulum, we'll need to know four things: the number of bobs \(n\), and the phase-space state of the pendulum, which we'll store in two 
            parts: the \(\theta_i\) and \(\dot{\theta}_i\), and the gravitational constant \(g\). To make our lives easier, we'll also give default values: \(n = 5\), 
            \(\theta_i = \frac{\pi}{2}\), \(\dot{\theta}_i = 0\) and \(g = 9.8\).
        </p>
        <p>
            We'll use the following code to do so:
            <pre>
<code>constructor(
    n = 5, 
    thetas = Array(n).fill(0.5*Math.PI), 
    thetaDots = Array(n).fill(0), 
    g = -9.8
) {
    this.n = n;
    this.thetas = thetas;
    this.thetaDots = thetaDots;
    this.g = g;
}</code>
            </pre>
        </p>
        <h3>The <code>A()</code> method</h3>
        <p>
            The \(A\) matrix only depends on \(\theta_i\) values, so we'll add <code>thetas</code> as the input parameter. We'll then create the \(A\) matrix as an array of arrays
            using <code>for</code> loops.
        </p>
        <pre>
<code>A(thetas) {
    let M = [];
    for (let i = 0; i < this.n; i++) {
        let row = [];
        for (let j = 0; j < this.n; j++) {
            row.push((this.n - Math.max(i, j)) * Math.cos(thetas[i] - thetas[j]));
        }
        M.push(row)
    }
    return M;
}</code>
        </pre>
        <h3>The <code>b()</code> method</h3>
        <p>
            The \(b\) vector depends on \(\theta_i\) values, \(\dot{\theta_i}\) values, and the gravitational constant \(g\). Since \(g\) is already defined as a property of the
            system, we just need to send \(\theta_i\) and \(\dot{\theta_i}\) as parameters. Similar to how we built \(A\), we'll use <code>for</code> loops to calculate the values
            of the vector.
        </p>
        <pre>
<code>b(thetas, thetaDots) {
    let v = [];
    for (let i = 0; i < this.n; i++) {
        let b_i = 0;
        for (let j = 0; j < this.n; j++) {
            b_i -= (this.n - Math.max(i, j)) * Math.sin(thetas[i] - thetas[j]) * thetaDots[j] ** 2;
        }
        b_i -= this.g * (this.n - i) * Math.sin(thetas[i]);
        v.push(b_i);
    }
    return v;
}</code>
        </pre>
        <h3>The <code>f()</code> method</h3>
        <p>
            The \(f\) function depends on \(\theta_i\) values, \(\dot{\theta_i}\) values, so we'll send them in as parameters. To calculate the \(\ddot{\theta}_i\) values, we'll
            use the <code>lusolve()</code> method from <code>math.js</code>. Because of how <code>math.js</code> returns the values, we'll need to extract the values from singleton
            arrays with <code class="nowrap">map(x => x[0])</code>.
        </p>
        <pre>
<code>f(thetas, thetaDots) {
    let A = this.A(thetas);
    let b = this.b(thetas, thetaDots);
    return [thetaDots, math.lusolve(A, b).map(x => x[0])];
}</code>
        </pre>
        <h3>The <code>RK4()</code> method</h3>
        <p>
            The RK4 method requires a timestep \(\Delta t\), \(\theta_i\) values, \(\dot{\theta_i}\) values. We can use the <code>math.add()</code> method to make adding the 
            different vectors together a little bit easier, but I've used the <code>map()</code> method to handle the scalar value multiplication.
        </p>
        <pre>
<code>RK4(dt, thetas, thetaDots) {
    let k1 = this.f(thetas, thetaDots);
    let k2 = this.f(math.add(thetas, k1[0].map(x => 0.5*dt*x)), math.add(thetaDots, k1[1].map(x => 0.5*dt*x)));
    let k3 = this.f(math.add(thetas, k2[0].map(x => 0.5*dt*x)), math.add(thetaDots, k2[1].map(x => 0.5*dt*x)));
    let k4 = this.f(math.add(thetas, k3[0].map(x => 1.0*dt*x)), math.add(thetaDots, k3[1].map(x => 1.0*dt*x)));

    let thetaDeltas    = math.add(k1[0], k2[0].map(x => 2 * x), k3[0].map(x => 2 * x), k4[0]).map(x => x * dt/6);
    let thetaDotDeltas = math.add(k1[1], k2[1].map(x => 2 * x), k3[1].map(x => 2 * x), k4[1]).map(x => x * dt/6);

    return [math.add(thetas, thetaDeltas), thetaDots = math.add(thetaDots, thetaDotDeltas)]
}</code>
        </pre>
        <h3>The <code>tick()</code> method</h3>
        <p>
            Now, most of the hard work is done! The <code>tick()</code> method just needs to take in a \(\Delta t\) value, and rewrite the current state of <code>thetas</code>
            and <code>thetaDots</code>.
        </p>
        <pre>
<code>tick(dt) {
    let newState = this.RK4(dt, this.thetas, this.thetaDots);
    this.thetas = newState[0];
    this.thetaDots = newState[1];
}</code>
        </pre>
        <h3>The <code>coordinates()</code> method</h3>
        <p>
            The last of the heavy math is here. We need to convert the current \(\theta_i\) of the pendulum state into \(x_i\) and \(y_i\) coordinates. Note that for this method,
            we are using the <code>get</code> keyword, which means when we instantiate our pendulum, we can "get" the coordinates of the object as if they were a property. This
            method only relies on internal values from the object, so we do not need to send any parameters.
        </p>
        <p>
            We do need to create, and return, a vector of the bob coordinates, so we start with an empty array, and push elements to it inside of a for loop. 
        </p>
        <pre>
<code>get coordinates() {
    let x = 0;
    let y = 0;
    let coords = [];
    for (let i = 0; i < this.thetas.length; i++) {
        let theta = this.thetas[i]
        x += Math.sin(theta);
        y += Math.cos(theta);
        coords.push({x:x, y:y})
    }
    return coords;
}</code>
        </pre>
        <p>
            The <code>Pendulum</code> class is now completed! Your <code>pendulum.js</code> file should look like
            <pre>
<code>class Pendulum {
    constructor(
        n = 5, 
        thetas = Array(n).fill(0.5*Math.PI), 
        thetaDots = Array(n).fill(0), 
        g = -9.8
    ) {
        this.n = n;
        this.thetas = thetas;
        this.thetaDots = thetaDots;
        this.g = g;
    }

    A(thetas) {
        let M = [];
        for (let i = 0; i < this.n; i++) {
            let row = [];
            for (let j = 0; j < this.n; j++) {
                row.push((this.n - Math.max(i, j)) * Math.cos(thetas[i] - thetas[j]));
            }
            M.push(row)
        }
        return M;
    }
    
    b(thetas, thetaDots) {
        let v = [];
        for (let i = 0; i < this.n; i++) {
            let b_i = 0;
            for (let j = 0; j < this.n; j++) {
                b_i -= (this.n - Math.max(i, j)) * Math.sin(thetas[i] - thetas[j]) * thetaDots[j] ** 2;
            }
            b_i -= this.g * (this.n - i) * Math.sin(thetas[i]);
            v.push(b_i);
        }
        return v;
    }
    
    f(thetas, thetaDots) {
        let A = this.A(thetas);
        let b = this.b(thetas, thetaDots);
        return [thetaDots, math.lusolve(A, b).map(x => x[0])];
    }
    
    RK4(dt, thetas, thetaDots) {
        let k1 = this.f(thetas, thetaDots);
        let k2 = this.f(math.add(thetas, k1[0].map(x => 0.5*dt*x)), math.add(thetaDots, k1[1].map(x => 0.5*dt*x)));
        let k3 = this.f(math.add(thetas, k2[0].map(x => 0.5*dt*x)), math.add(thetaDots, k2[1].map(x => 0.5*dt*x)));
        let k4 = this.f(math.add(thetas, k3[0].map(x => 1.0*dt*x)), math.add(thetaDots, k3[1].map(x => 1.0*dt*x)));
 
        let thetaDeltas    = math.add(k1[0], k2[0].map(x => 2 * x), k3[0].map(x => 2 * x), k4[0]).map(x => x * dt/6);
        let thetaDotDeltas = math.add(k1[1], k2[1].map(x => 2 * x), k3[1].map(x => 2 * x), k4[1]).map(x => x * dt/6);
    
        return [math.add(thetas, thetaDeltas), thetaDots = math.add(thetaDots, thetaDotDeltas)]
    }

    tick(dt) {
        let newState = this.RK4(dt, this.thetas, this.thetaDots);
        this.thetas = newState[0];
        this.thetaDots = newState[1];
    }

    get coordinates() {
        let x = 0;
        let y = 0;
        let coords = [];
        for (let i = 0; i < this.thetas.length; i++) {
            let theta = this.thetas[i]
            x += Math.sin(theta);
            y += Math.cos(theta);
            coords.push({x:x, y:y})
        }
        return coords;
    }
}</code>
            </pre>
        </p>
        <p>
            Now that we're done with the <code>Pendulum</code> class, we can finish up with the <code>index.js</code> file and make a running simulation!
        </p>     
        <h2><code>index.js</code></h2>
        <p>Here's our gameplan for <code>index.js</code>.
            <ul>
                <li>First, we need to instantiate a pendulum object from the <code>Pendulum</code> class,</li>
                <li>then, we'll make a reference to the canvas element,</li>
                <li>next, we'll create a function that draws the current state of the n-tuple pendulum, and</li>
                <li>finally, we'll animate the draw function.</li>
            </ul>
        </p>
        <h3>Instantiate pendulum object</h3>
        <p>
            We did all of the hard work in creating the <code>Pendulum</code> class, so this part is now easy. 
        </p>
        <pre>
<code>let pendulum = new Pendulum();</code>
        </pre>
        <h3>Reference the canvas element</h3>
        <p>
            Here, we select the <code>canvas</code> element with the <code>getElementById()</code> method. We also need to establish a drawing context on the canvas; since we're
            drawing a two-dimensional representation, we create the <code>"2d"</code> context connected to the <code>canvas</code> element.
        </p>
        <pre>
<code>let canvas = document.getElementById('canvas');
let context = canvas.getContext('2d');</code>
        </pre>
        <h3>Create <code>draw()</code> function</h3>
        <p>
            Before we can create the <code>draw()</code> function, we'll need to scale the output of our pendulum to fit the canvas. We'll do this with two scale functions:
            <code>xScale()</code> and <code>yScale()</code>
        </p>
        <pre>
<code>var xScale = x => x * (0.5*canvas.width/pendulum.n);
var yScale = x => -x * (0.5*canvas.height/pendulum.n);</code>
        </pre>
        <p>
            Note that the <code>yScale()</code> function flips the sign, because when drawing on the <code>canvas</code>, <code>y</code> starts at <code>0</code> at the 
            <em>top</em> of the <code>canvas</code>, and as <code>y</code> increases, it goes <em>down</em>. We've done all our math and coding with the assumption that as 
            <code>y</code> increases, it moves <em>up</em>, so we need to flip the sign.
        </p>
        <p>
            Now we can start filling in the <code>draw()</code> function. First, we need to get the current coordinates from the <code>pendulum</code> instance. Then we will
            initialize the first coordinates at the center of the canvas.
        </p>
        <pre>
<code>function draw() {
    let coords = pendulum.coordinates;

    let x1 = 0.5*canvas.width;
    let y1 = 0.5*canvas.height    
}</code>
        </pre>
        <p>
            Next, we will create a <code>for</code> loop to go through all the pendulum coordinates, and set the new screen coordinates. (Remember, this is still inside the 
        <code>draw()</code> function).
        </p>
        <pre>
<code>    for (let i = 0; i < pendulum.n; i++) {
        let x2 = 0.5*canvas.width + xScale(coords[i].x);
        let y2 = 0.5*canvas.height + yScale(coords[i].y);
    }</code>
        </pre>
        <p>
            Now we will use the <code>canvas</code> functions to draw the rod and bob for the current coordinate in the for loop.
        </p>
        <pre>
<code>        context.fillStyle = 'red';
        context.strokeStyle = 'black';
        context.lineWidth = 2;
        context.beginPath();
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
        context.stroke();

        context.beginPath();
        context.arc(x2, y2, 3, 0, Math.PI * 2, true);
        context.fill();</code>
        </pre>
        <p>
            Finally, at the end of the <code>for</code> loop, we will set <code>x1</code> and <code>y1</code> to the current coordinates, so they will become the new starting
            points in the next iteration.
        </p>
        <pre>
<code>        x1 = x2;
        y1 = y2;
</code>
        </pre>
        <p>Our <code>draw()</code> function is now complete! It should look like</p>
        <pre>
<code>function draw() {
    let coords = pendulum.coordinates;

    let x1 = 0.5*canvas.width;
    let y1 = 0.5*canvas.height    

    for (let i = 0; i < pendulum.n; i++) {
        let x2 = 0.5*canvas.width + xScale(coords[i].x);
        let y2 = 0.5*canvas.height + yScale(coords[i].y);

        context.fillStyle = 'red';
        context.strokeStyle = 'black';
        context.lineWidth = 2;
        context.beginPath();
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
        context.stroke();

        context.beginPath();
        context.arc(x2, y2, 3, 0, Math.PI * 2, true);
        context.fill();

        x1 = x2;
        y1 = y2;
    }
}</code>
        </pre>
        <h3>Animate</h3>
        <p>
            Finally, we will create a function to handle the animation. This function will
            <ul>
                <li>Clear the canvas,</li>
                <li>Call the <code>draw()</code> function,</li>
                <li>Call the <code>tick()</code> method on the <code>pendulum</code> instance,</li>
                <li>And call itself within a <code>requestAnimationFrame()</code> function<sup><a href="#footnote-2" id="footnote-2-referrer">[2]</a></sup></li>
            </ul>
            The code to do so is
        </p>
        <pre>
<code>function animate() {
    context.clearRect(0, 0, canvas.width, canvas.height);
    draw();
    pendulum.tick(1/60);
    requestAnimationFrame(animate);
}</code>
        </pre>
        <p>the last thing we need to do is call the <code>animate()</code> function, which we will do inside a <code>requestAnimationFrame()</code> call.</p>
        <pre>
<code>requestAnimationFrame(animate);</code>
        </pre>

        <p>
            And with that, your <code>index.js</code> file is complete! Your code should look like
            <pre>
<code>let pendulum = new Pendulum();

let canvas = document.getElementById('canvas');
let context = canvas.getContext('2d');

var xScale = x => x * (0.5*canvas.width/pendulum.n);
var yScale = x => -x * (0.5*canvas.height/pendulum.n);

function draw() {
    let coords = pendulum.coordinates;

    let x1 = 0.5*canvas.width;
    let y1 = 0.5*canvas.height    

    for (let i = 0; i < pendulum.n; i++) {
        let x2 = 0.5*canvas.width + xScale(coords[i].x);
        let y2 = 0.5*canvas.height + yScale(coords[i].y);

        context.fillStyle = 'red';
        context.strokeStyle = 'black';
        context.lineWidth = 2;
        context.beginPath();
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
        context.stroke();

        context.beginPath();
        context.arc(x2, y2, 3, 0, Math.PI * 2, true);
        context.fill();

        x1 = x2;
        y1 = y2;
    }
}

function animate() {
    context.clearRect(0, 0, canvas.width, canvas.height);
    draw();
    pendulum.tick(1/60);
    requestAnimationFrame(animate);
}

requestAnimationFrame(animate);</code>
        </pre>
        </p>
        <p>
            And that's it! You should be able to open <code>index.html</code> in your modern browser of choice, and see a quintuple pendulum being animated in real time. 
        </p>
        </section>
        <section id="congrats" class="green aside">
            <h2>Congratulations!</h2>
        </section>
        <p>
            If you liked this content, please consider <a class="coffee" href="http://buymeacoffee.com/travisdoesmath">buying me a coffee</a>
        </p>
        <section id="footnotes">
            <hr>
            <h4>Footnotes</h4>
            <p id="footnote-1"><sup><a href="#footnote-1-referrer">[1]</a></sup>This derivation is indebted to <a href="https://diego.assencio.com/?index=1500c66ae7ab27bb0106467c68feebc6#post_1500c66ae7ab27bb0106467c68feebc6_fig_1">Diego Assencio's derivation of the Lagrangian for the double pendulum</a></p>
            <p id="footnote-2"><sup><a href="#footnote-2-referrer">[2]</a></sup>More info about how <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame"><code>requestAnimationFrame()</code></a> works can be found at MDN.</p>
        </section>
        <section id="copyright">
            <hr>
            <p><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</p>
        </section>
    </div>
    <script>hljs.highlightAll();</script>
    <script src="example/pendulum.js"></script>
    <script src="main.js"></script>
</body>
</html>